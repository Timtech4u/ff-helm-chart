// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/argoproj/argo-cd/v2/pkg/apis/applicationset/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1"
)

// Utility struct for a reference to a secret key.
#SecretRef: {
	secretName: string @go(SecretName)
	key:        string @go(Key)
}

// ApplicationSet is a set of Application resources
// +kubebuilder:object:root=true
// +kubebuilder:resource:path=applicationsets,shortName=appset;appsets
// +kubebuilder:subresource:status
#ApplicationSet: {
	metav1.#TypeMeta
	metadata: metav1.#ObjectMeta    @go(ObjectMeta)
	spec:     #ApplicationSetSpec   @go(Spec)
	status?:  #ApplicationSetStatus @go(Status)
}

// ApplicationSetSpec represents a class of application set state.
#ApplicationSetSpec: {
	generators: [...#ApplicationSetGenerator] @go(Generators,[]ApplicationSetGenerator)
	template:    #ApplicationSetTemplate          @go(Template)
	syncPolicy?: null | #ApplicationSetSyncPolicy @go(SyncPolicy,*ApplicationSetSyncPolicy)
}

// ApplicationSetSyncPolicy configures how generated Applications will relate to their
// ApplicationSet.
#ApplicationSetSyncPolicy: {
	// PreserveResourcesOnDeletion will preserve resources on deletion. If PreserveResourcesOnDeletion is set to true, these Applications will not be deleted.
	preserveResourcesOnDeletion?: bool @go(PreserveResourcesOnDeletion)
}

// ApplicationSetTemplate represents argocd ApplicationSpec
#ApplicationSetTemplate: {
	metadata: #ApplicationSetTemplateMeta @go(ApplicationSetTemplateMeta)
	spec:     v1alpha1.#ApplicationSpec   @go(Spec)
}

// ApplicationSetTemplateMeta represents the Argo CD application fields that may
// be used for Applications generated from the ApplicationSet (based on metav1.ObjectMeta)
#ApplicationSetTemplateMeta: {
	name?:      string @go(Name)
	namespace?: string @go(Namespace)
	labels?: {[string]: string} @go(Labels,map[string]string)
	annotations?: {[string]: string} @go(Annotations,map[string]string)
	finalizers?: [...string] @go(Finalizers,[]string)
}

// ApplicationSetGenerator represents a generator at the top level of an ApplicationSet.
#ApplicationSetGenerator: {
	list?:                    null | #ListGenerator        @go(List,*ListGenerator)
	clusters?:                null | #ClusterGenerator     @go(Clusters,*ClusterGenerator)
	git?:                     null | #GitGenerator         @go(Git,*GitGenerator)
	scmProvider?:             null | #SCMProviderGenerator @go(SCMProvider,*SCMProviderGenerator)
	clusterDecisionResource?: null | #DuckTypeGenerator    @go(ClusterDecisionResource,*DuckTypeGenerator)
	pullRequest?:             null | #PullRequestGenerator @go(PullRequest,*PullRequestGenerator)
	matrix?:                  null | #MatrixGenerator      @go(Matrix,*MatrixGenerator)
	merge?:                   null | #MergeGenerator       @go(Merge,*MergeGenerator)
}

// ApplicationSetNestedGenerator represents a generator nested within a combination-type generator (MatrixGenerator or
// MergeGenerator).
#ApplicationSetNestedGenerator: {
	list?:                    null | #ListGenerator        @go(List,*ListGenerator)
	clusters?:                null | #ClusterGenerator     @go(Clusters,*ClusterGenerator)
	git?:                     null | #GitGenerator         @go(Git,*GitGenerator)
	scmProvider?:             null | #SCMProviderGenerator @go(SCMProvider,*SCMProviderGenerator)
	clusterDecisionResource?: null | #DuckTypeGenerator    @go(ClusterDecisionResource,*DuckTypeGenerator)
	pullRequest?:             null | #PullRequestGenerator @go(PullRequest,*PullRequestGenerator)
}

#ApplicationSetNestedGenerators: [...#ApplicationSetNestedGenerator]

// ApplicationSetTerminalGenerator represents a generator nested within a nested generator (for example, a list within
// a merge within a matrix). A generator at this level may not be a combination-type generator (MatrixGenerator or
// MergeGenerator). ApplicationSet enforces this nesting depth limit because CRDs do not support recursive types.
// https://github.com/kubernetes-sigs/controller-tools/issues/477
#ApplicationSetTerminalGenerator: {
	list?:                    null | #ListGenerator        @go(List,*ListGenerator)
	clusters?:                null | #ClusterGenerator     @go(Clusters,*ClusterGenerator)
	git?:                     null | #GitGenerator         @go(Git,*GitGenerator)
	scmProvider?:             null | #SCMProviderGenerator @go(SCMProvider,*SCMProviderGenerator)
	clusterDecisionResource?: null | #DuckTypeGenerator    @go(ClusterDecisionResource,*DuckTypeGenerator)
	pullRequest?:             null | #PullRequestGenerator @go(PullRequest,*PullRequestGenerator)
}

#ApplicationSetTerminalGenerators: [...#ApplicationSetTerminalGenerator]

// ListGenerator include items info
#ListGenerator: {
	template?: #ApplicationSetTemplate @go(Template)
}

// MatrixGenerator generates the cartesian product of two sets of parameters. The parameters are defined by two nested
// generators.
#MatrixGenerator: {
	generators: [...#ApplicationSetNestedGenerator] @go(Generators,[]ApplicationSetNestedGenerator)
	template?: #ApplicationSetTemplate @go(Template)
}

// NestedMatrixGenerator is a MatrixGenerator nested under another combination-type generator (MatrixGenerator or
// MergeGenerator). NestedMatrixGenerator does not have an override template, because template overriding has no meaning
// within the constituent generators of combination-type generators.
//
// NOTE: Nested matrix generator is not included directly in the CRD struct, instead it is included
// as a generic 'apiextensionsv1.JSON' object, and then marshalled into a NestedMatrixGenerator
// when processed.
#NestedMatrixGenerator: {
	generators: #ApplicationSetTerminalGenerators @go(Generators)
}

// MergeGenerator merges the output of two or more generators. Where the values for all specified merge keys are equal
// between two sets of generated parameters, the parameter sets will be merged with the parameters from the latter
// generator taking precedence. Parameter sets with merge keys not present in the base generator's params will be
// ignored.
// For example, if the first generator produced [{a: '1', b: '2'}, {c: '1', d: '1'}] and the second generator produced
// [{'a': 'override'}], the united parameters for merge keys = ['a'] would be
// [{a: 'override', b: '1'}, {c: '1', d: '1'}].
//
// MergeGenerator supports template overriding. If a MergeGenerator is one of multiple top-level generators, its
// template will be merged with the top-level generator before the parameters are applied.
#MergeGenerator: {
	generators: [...#ApplicationSetNestedGenerator] @go(Generators,[]ApplicationSetNestedGenerator)
	mergeKeys: [...string] @go(MergeKeys,[]string)
	template?: #ApplicationSetTemplate @go(Template)
}

// NestedMergeGenerator is a MergeGenerator nested under another combination-type generator (MatrixGenerator or
// MergeGenerator). NestedMergeGenerator does not have an override template, because template overriding has no meaning
// within the constituent generators of combination-type generators.
//
// NOTE: Nested merge generator is not included directly in the CRD struct, instead it is included
// as a generic 'apiextensionsv1.JSON' object, and then marshalled into a NestedMergeGenerator
// when processed.
#NestedMergeGenerator: {
	generators: #ApplicationSetTerminalGenerators @go(Generators)
	mergeKeys: [...string] @go(MergeKeys,[]string)
}

// ClusterGenerator defines a generator to match against clusters registered with ArgoCD.
#ClusterGenerator: {
	// Selector defines a label selector to match against all clusters registered with ArgoCD.
	// Clusters today are stored as Kubernetes Secrets, thus the Secret labels will be used
	// for matching the selector.
	selector?: metav1.#LabelSelector   @go(Selector)
	template?: #ApplicationSetTemplate @go(Template)

	// Values contains key/value pairs which are passed directly as parameters to the template
	values?: {[string]: string} @go(Values,map[string]string)
}

// DuckType defines a generator to match against clusters registered with ArgoCD.
#DuckTypeGenerator: {
	// ConfigMapRef is a ConfigMap with the duck type definitions needed to retrieve the data
	//              this includes apiVersion(group/version), kind, matchKey and validation settings
	// Name is the resource name of the kind, group and version, defined in the ConfigMapRef
	// RequeueAfterSeconds is how long before the duckType will be rechecked for a change
	configMapRef:         string                  @go(ConfigMapRef)
	name?:                string                  @go(Name)
	requeueAfterSeconds?: null | int64            @go(RequeueAfterSeconds,*int64)
	labelSelector?:       metav1.#LabelSelector   @go(LabelSelector)
	template?:            #ApplicationSetTemplate @go(Template)

	// Values contains key/value pairs which are passed directly as parameters to the template
	values?: {[string]: string} @go(Values,map[string]string)
}

#GitGenerator: {
	repoURL: string @go(RepoURL)
	directories?: [...#GitDirectoryGeneratorItem] @go(Directories,[]GitDirectoryGeneratorItem)
	files?: [...#GitFileGeneratorItem] @go(Files,[]GitFileGeneratorItem)
	revision:             string                  @go(Revision)
	requeueAfterSeconds?: null | int64            @go(RequeueAfterSeconds,*int64)
	template?:            #ApplicationSetTemplate @go(Template)
}

#GitDirectoryGeneratorItem: {
	path:     string @go(Path)
	exclude?: bool   @go(Exclude)
}

#GitFileGeneratorItem: {
	path: string @go(Path)
}

// SCMProviderGenerator defines a generator that scrapes a SCMaaS API to find candidate repos.
#SCMProviderGenerator: {
	// Which provider to use and config for it.
	github?:          null | #SCMProviderGeneratorGithub          @go(Github,*SCMProviderGeneratorGithub)
	gitlab?:          null | #SCMProviderGeneratorGitlab          @go(Gitlab,*SCMProviderGeneratorGitlab)
	bitbucket?:       null | #SCMProviderGeneratorBitbucket       @go(Bitbucket,*SCMProviderGeneratorBitbucket)
	bitbucketServer?: null | #SCMProviderGeneratorBitbucketServer @go(BitbucketServer,*SCMProviderGeneratorBitbucketServer)
	gitea?:           null | #SCMProviderGeneratorGitea           @go(Gitea,*SCMProviderGeneratorGitea)

	// Filters for which repos should be considered.
	filters?: [...#SCMProviderGeneratorFilter] @go(Filters,[]SCMProviderGeneratorFilter)

	// Which protocol to use for the SCM URL. Default is provider-specific but ssh if possible. Not all providers
	// necessarily support all protocols.
	cloneProtocol?: string @go(CloneProtocol)

	// Standard parameters.
	requeueAfterSeconds?: null | int64            @go(RequeueAfterSeconds,*int64)
	template?:            #ApplicationSetTemplate @go(Template)
}

// SCMProviderGeneratorGitea defines a connection info specific to Gitea.
#SCMProviderGeneratorGitea: {
	// Gitea organization or user to scan. Required.
	owner: string @go(Owner)

	// The Gitea URL to talk to. For example https://gitea.mydomain.com/.
	api: string @go(API)

	// Authentication token reference.
	tokenRef?: null | #SecretRef @go(TokenRef,*SecretRef)

	// Scan all branches instead of just the default branch.
	allBranches?: bool @go(AllBranches)

	// Allow self-signed TLS / Certificates; default: false
	insecure?: bool @go(Insecure)
}

// SCMProviderGeneratorGithub defines connection info specific to GitHub.
#SCMProviderGeneratorGithub: {
	// GitHub org to scan. Required.
	organization: string @go(Organization)

	// The GitHub API URL to talk to. If blank, use https://api.github.com/.
	api?: string @go(API)

	// Authentication token reference.
	tokenRef?: null | #SecretRef @go(TokenRef,*SecretRef)

	// Scan all branches instead of just the default branch.
	allBranches?: bool @go(AllBranches)
}

// SCMProviderGeneratorGitlab defines connection info specific to Gitlab.
#SCMProviderGeneratorGitlab: {
	// Gitlab group to scan. Required.  You can use either the project id (recommended) or the full namespaced path.
	group: string @go(Group)

	// Recurse through subgroups (true) or scan only the base group (false).  Defaults to "false"
	includeSubgroups?: bool @go(IncludeSubgroups)

	// The Gitlab API URL to talk to.
	api?: string @go(API)

	// Authentication token reference.
	tokenRef?: null | #SecretRef @go(TokenRef,*SecretRef)

	// Scan all branches instead of just the default branch.
	allBranches?: bool @go(AllBranches)
}

// SCMProviderGeneratorBitbucket defines connection info specific to Bitbucket Cloud (API version 2).
#SCMProviderGeneratorBitbucket: {
	// Bitbucket workspace to scan. Required.
	owner: string @go(Owner)

	// Bitbucket user to use when authenticating.  Should have a "member" role to be able to read all repositories and branches.  Required
	user: string @go(User)

	// The app password to use for the user.  Required. See: https://support.atlassian.com/bitbucket-cloud/docs/app-passwords/
	appPasswordRef?: null | #SecretRef @go(AppPasswordRef,*SecretRef)

	// Scan all branches instead of just the main branch.
	allBranches?: bool @go(AllBranches)
}

// SCMProviderGeneratorBitbucketServer defines connection info specific to Bitbucket Server.
#SCMProviderGeneratorBitbucketServer: {
	// Project to scan. Required.
	project: string @go(Project)

	// The Bitbucket Server REST API URL to talk to. Required.
	api: string @go(API)

	// Credentials for Basic auth
	basicAuth?: null | #BasicAuthBitbucketServer @go(BasicAuth,*BasicAuthBitbucketServer)

	// Scan all branches instead of just the default branch.
	allBranches?: bool @go(AllBranches)
}

// SCMProviderGeneratorFilter is a single repository filter.
// If multiple filter types are set on a single struct, they will be AND'd together. All filters must
// pass for a repo to be included.
#SCMProviderGeneratorFilter: {
	// A regex for repo names.
	repositoryMatch?: null | string @go(RepositoryMatch,*string)

	// An array of paths, all of which must exist.
	pathsExist?: [...string] @go(PathsExist,[]string)

	// An array of paths, all of which must not exist.
	pathsDoNotExist?: [...string] @go(PathsDoNotExist,[]string)

	// A regex which must match at least one label.
	labelMatch?: null | string @go(LabelMatch,*string)

	// A regex which must match the branch name.
	branchMatch?: null | string @go(BranchMatch,*string)
}

// PullRequestGenerator defines a generator that scrapes a PullRequest API to find candidate pull requests.
#PullRequestGenerator: {
	// Which provider to use and config for it.
	github?:          null | #PullRequestGeneratorGithub          @go(Github,*PullRequestGeneratorGithub)
	gitea?:           null | #PullRequestGeneratorGitea           @go(Gitea,*PullRequestGeneratorGitea)
	bitbucketServer?: null | #PullRequestGeneratorBitbucketServer @go(BitbucketServer,*PullRequestGeneratorBitbucketServer)

	// Filters for which pull requests should be considered.
	filters?: [...#PullRequestGeneratorFilter] @go(Filters,[]PullRequestGeneratorFilter)

	// Standard parameters.
	requeueAfterSeconds?: null | int64            @go(RequeueAfterSeconds,*int64)
	template?:            #ApplicationSetTemplate @go(Template)
}

// PullRequestGenerator defines connection info specific to Gitea.
#PullRequestGeneratorGitea: {
	// Gitea org or user to scan. Required.
	owner: string @go(Owner)

	// Gitea repo name to scan. Required.
	repo: string @go(Repo)

	// The Gitea API URL to talk to. Required
	api: string @go(API)

	// Authentication token reference.
	tokenRef?: null | #SecretRef @go(TokenRef,*SecretRef)

	// Allow insecure tls, for self-signed certificates; default: false.
	insecure?: bool @go(Insecure)
}

// PullRequestGenerator defines connection info specific to GitHub.
#PullRequestGeneratorGithub: {
	// GitHub org or user to scan. Required.
	owner: string @go(Owner)

	// GitHub repo name to scan. Required.
	repo: string @go(Repo)

	// The GitHub API URL to talk to. If blank, use https://api.github.com/.
	api?: string @go(API)

	// Authentication token reference.
	tokenRef?: null | #SecretRef @go(TokenRef,*SecretRef)

	// Labels is used to filter the PRs that you want to target
	labels?: [...string] @go(Labels,[]string)
}

// PullRequestGenerator defines connection info specific to BitbucketServer.
#PullRequestGeneratorBitbucketServer: {
	// Project to scan. Required.
	project: string @go(Project)

	// Repo name to scan. Required.
	repo: string @go(Repo)

	// The Bitbucket REST API URL to talk to e.g. https://bitbucket.org/rest Required.
	api: string @go(API)

	// Credentials for Basic auth
	basicAuth?: null | #BasicAuthBitbucketServer @go(BasicAuth,*BasicAuthBitbucketServer)
}

// BasicAuthBitbucketServer defines the username/(password or personal access token) for Basic auth.
#BasicAuthBitbucketServer: {
	// Username for Basic auth
	username: string @go(Username)

	// Password (or personal access token) reference.
	passwordRef?: null | #SecretRef @go(PasswordRef,*SecretRef)
}

// PullRequestGeneratorFilter is a single pull request filter.
// If multiple filter types are set on a single struct, they will be AND'd together. All filters must
// pass for a pull request to be included.
#PullRequestGeneratorFilter: {
	branchMatch?: null | string @go(BranchMatch,*string)
}

// ApplicationSetStatus defines the observed state of ApplicationSet
#ApplicationSetStatus: {
	// INSERT ADDITIONAL STATUS FIELD - define observed state of cluster
	// Important: Run "make" to regenerate code after modifying this file
	conditions?: [...#ApplicationSetCondition] @go(Conditions,[]ApplicationSetCondition)
}

// ApplicationSetCondition contains details about an applicationset condition, which is usally an error or warning
#ApplicationSetCondition: {
	// Type is an applicationset condition type
	type: #ApplicationSetConditionType @go(Type) @protobuf(1,bytes,opt)

	// Message contains human-readable message indicating details about condition
	message: string @go(Message) @protobuf(2,bytes,opt)

	// LastTransitionTime is the time the condition was last observed
	lastTransitionTime?: null | metav1.#Time @go(LastTransitionTime,*metav1.Time) @protobuf(3,bytes,opt)

	// True/False/Unknown
	status: #ApplicationSetConditionStatus @go(Status) @protobuf(4,bytes,opt)

	//Single word camelcase representing the reason for the status eg ErrorOccurred
	reason: string @go(Reason) @protobuf(5,bytes,opt)
}

// SyncStatusCode is a type which represents possible comparison results
#ApplicationSetConditionStatus: string // #enumApplicationSetConditionStatus

#enumApplicationSetConditionStatus:
	#ApplicationSetConditionStatusTrue |
	#ApplicationSetConditionStatusFalse |
	#ApplicationSetConditionStatusUnknown

// ApplicationSetConditionStatusTrue indicates that a application has been successfully established
#ApplicationSetConditionStatusTrue: #ApplicationSetConditionStatus & "True"

// ApplicationSetConditionStatusFalse indicates that a application attempt has failed
#ApplicationSetConditionStatusFalse: #ApplicationSetConditionStatus & "False"

// ApplicationSetConditionStatusUnknown indicates that the application condition status could not be reliably determined
#ApplicationSetConditionStatusUnknown: #ApplicationSetConditionStatus & "Unknown"

// ApplicationSetConditionType represents type of application condition. Type name has following convention:
// prefix "Error" means error condition
// prefix "Warning" means warning condition
// prefix "Info" means informational condition
#ApplicationSetConditionType: string // #enumApplicationSetConditionType

#enumApplicationSetConditionType:
	#ApplicationSetConditionErrorOccurred |
	#ApplicationSetConditionParametersGenerated |
	#ApplicationSetConditionResourcesUpToDate

#ApplicationSetConditionErrorOccurred:       #ApplicationSetConditionType & "ErrorOccurred"
#ApplicationSetConditionParametersGenerated: #ApplicationSetConditionType & "ParametersGenerated"
#ApplicationSetConditionResourcesUpToDate:   #ApplicationSetConditionType & "ResourcesUpToDate"

#ApplicationSetReasonType: string

#ApplicationSetReasonErrorOccurred:                    "ErrorOccurred"
#ApplicationSetReasonApplicationSetUpToDate:           "ApplicationSetUpToDate"
#ApplicationSetReasonParametersGenerated:              "ParametersGenerated"
#ApplicationSetReasonApplicationGenerated:             "ApplicationGeneratedSuccessfully"
#ApplicationSetReasonUpdateApplicationError:           "UpdateApplicationError"
#ApplicationSetReasonApplicationParamsGenerationError: "ApplicationGenerationFromParamsError"
#ApplicationSetReasonRenderTemplateParamsError:        "RenderTemplateParamsError"
#ApplicationSetReasonCreateApplicationError:           "CreateApplicationError"
#ApplicationSetReasonDeleteApplicationError:           "DeleteApplicationError"
#ApplicationSetReasonRefreshApplicationError:          "RefreshApplicationError"
#ApplicationSetReasonApplicationValidationError:       "ApplicationValidationError"

// ApplicationSetList contains a list of ApplicationSet
// +kubebuilder:object:root=true
#ApplicationSetList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)
	items: [...#ApplicationSet] @go(Items,[]ApplicationSet)
}
